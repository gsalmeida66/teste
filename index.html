versão comparativa

<!DOCTYPE HTML>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Comparativo de Planos de Retenção</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f7f9fc;
    }
  </style>
</head>
<body>

  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    // Função auxiliar para calcular o número de dias úteis entre duas datas
    const getBusinessDays = (startDate, endDate) => {
      let count = 0;
      const currentDate = new Date(startDate);
      while (currentDate <= endDate) {
        const dayOfWeek = currentDate.getDay();
        if (dayOfWeek !== 0 && dayOfWeek !== 6) { // 0 = Domingo, 6 = Sábado
          count++;
        }
        currentDate.setDate(currentDate.getDate() + 1);
      }
      return count;
    };

    // Função auxiliar para adicionar dias úteis a uma data
    const addBusinessDays = (date, days) => {
      const result = new Date(date);
      let addedDays = 0;
      while (addedDays < days) {
        result.setDate(result.getDate() + 1);
        if (result.getDay() !== 0 && result.getDay() !== 6) {
          addedDays++;
        }
      }
      return result;
    };

    // Função auxiliar para formatar a data
    const formatDate = (date) => {
      if (!date) return '';
      const d = new Date(date);
      const options = { month: 'short', day: 'numeric' };
      return d.toLocaleDateString('pt-BR', options);
    };

    // Componente Timeline para exibir um cronograma
    const Timeline = ({ projects, title }) => {
      const timelineStartDateBotSac = new Date('2025-06-09T00:00:00'); // Data de início da linha do tempo
      const daysPerPixel = 40; // Quantidade de pixels por dia útil
      const minWidthTimeline = 3000; // Largura mínima da linha do tempo para garantir espaço

      const [taskPositions, setTaskPositions] = useState({}); // Estado para armazenar as posições das tarefas

      // Efeito para calcular as posições das tarefas sempre que os projetos mudarem
      useEffect(() => {
        const allTasks = projects.flatMap(p => p.tasks.map(t => ({ ...t, projectId: p.id })));
        const positions = {};

        let tasksToProcess = [...allTasks];
        let processedCount = 0;
        const maxIterations = allTasks.length * allTasks.length; 

        for (let i = 0; i < maxIterations && processedCount < allTasks.length; i++) {
          const initialTasksToProcessCount = tasksToProcess.length;
          tasksToProcess = tasksToProcess.filter(task => {
            let startDate;
            let canProcess = true;

            if (task.startDate) {
                startDate = task.startDate;
            } else if (task.predecessors && task.predecessors.length > 0) {
              const predecessorEndDates = task.predecessors.map(predId => {
                const predIdParts = predId.split(':');
                const predecessorProjectId = predIdParts.length > 1 ? predIdParts[0] : task.projectId;
                const predecessorTaskId = predIdParts.length > 1 ? predIdParts[1] : predIdParts[0];
                const predPos = positions[predecessorTaskId]; 
                
                if (!predPos) {
                    canProcess = false; 
                    return timelineStartDateBotSac; 
                }
                return addBusinessDays(predPos.startDate, predPos.duration - 1);
              });

              if (!canProcess) return true; 

              startDate = addBusinessDays(new Date(Math.max(...predecessorEndDates)), 1);
            } else {
              startDate = timelineStartDateBotSac;
            }
            
            if (canProcess) {
              const businessDaysFromStart = getBusinessDays(timelineStartDateBotSac, startDate);
              const left = (businessDaysFromStart - 1) * daysPerPixel;
              const width = task.duration * daysPerPixel;
              
              positions[task.id] = { startDate, duration: task.duration, left, width };
              processedCount++;
              return false; 
            }
            return true; 
          });

          if (tasksToProcess.length === initialTasksToProcessCount && tasksToProcess.length > 0) {
            console.warn("Não foi possível processar todas as tarefas. Possíveis dependências circulares ou predecessores ausentes.");
            break;
          }
        }
        
        setTaskPositions(positions);
      }, [projects]); 

      // Retorna a cor da barra da tarefa com base no status
      const getTaskColor = (status) => {
        switch (status) {
          case 'Concluída':
            return 'bg-green-500';
          case 'Em Andamento':
            return 'bg-blue-500';
          default:
            return 'bg-gray-400';
        }
      };

      // Retorna as datas para a exibição no eixo X da linha do tempo
      const getTimelineDates = () => {
        const timelineEndDateHardLimit = new Date('2025-11-30T23:59:59'); 
        
        let maxProjectEndDate = timelineStartDateBotSac; 
        projects.forEach(project => {
            project.tasks.forEach(task => {
                const pos = taskPositions[task.id];
                if (pos && pos.startDate) {
                    const taskActualEndDate = addBusinessDays(pos.startDate, pos.duration);
                    if (taskActualEndDate.getTime() > maxProjectEndDate.getTime()) {
                        maxProjectEndDate = taskActualEndDate;
                    }
                }
            });
        });

        const displayEndDate = new Date(Math.min(timelineEndDateHardLimit.getTime(), maxProjectEndDate.getTime()));
        
        let currentDate = new Date(timelineStartDateBotSac);
        
        const markers = [];
        while(currentDate <= displayEndDate) {
          if (currentDate.getDay() === 1) { 
            markers.push(new Date(currentDate));
          }
          currentDate.setDate(currentDate.getDate() + 1);
        }
        
        return markers;
      };

      return (
        <div className="bg-white p-8 rounded-2xl shadow-xl w-full max-w-full">
          <h2 className="text-2xl font-bold text-center text-gray-800 mb-6">{title}</h2>
          {/* Legenda de status */}
          <div className="flex justify-end space-x-4 mb-4">
            <div className="flex items-center">
              <div className="w-4 h-4 rounded-full bg-green-500 mr-2"></div>
              <span className="text-sm text-gray-600">Concluída</span>
            </div>
            <div className="flex items-center">
              <div className="w-4 h-4 rounded-full bg-blue-500 mr-2"></div>
              <span className="text-sm text-gray-600">Em Andamento</span>
            </div>
            <div className="flex items-center">
              <div className="w-4 h-4 rounded-full bg-gray-400 mr-2"></div>
              <span className="text-sm text-gray-600">Não Iniciado</span>
            </div>
          </div>
          {/* Container principal para nomes de projetos fixos e cronograma rolável */}
          <div className="flex">
            {/* Coluna para nomes dos projetos (fixa) */}
            <div className="flex-shrink-0 w-32 bg-white z-30"> 
              {/* Espaço para alinhar com o eixo X do cronograma */}
              <div className="h-16"></div> 
              <div className="space-y-6"> {/* Adicionado space-y-6 aqui para espaçamento vertical */}
                {projects.map(project => (
                  <div key={project.id} className="h-16 flex items-center text-sm font-semibold text-gray-700 py-2">
                    {project.name}
                  </div>
                ))}
              </div>
            </div>

            {/* Coluna para o conteúdo do cronograma (rolável) */}
            <div className="flex-grow relative overflow-x-auto pb-6">
              {/* Container para datas e linha do eixo */}
              <div className="relative h-16 mb-4" style={{ minWidth: `${minWidthTimeline}px` }}> 
                {/* Datas posicionadas no topo */}
                <div className="absolute top-0 w-full flex justify-between text-xs text-gray-500 z-10">
                  {getTimelineDates().map((date, index) => (
                    <div key={index} className="text-center absolute" style={{ left: `${(getBusinessDays(timelineStartDateBotSac, date) - 1) * daysPerPixel}px` }}>
                      {formatDate(date)}
                    </div>
                  ))}
                </div>
                {/* A linha horizontal principal do eixo, posicionada na parte inferior */}
                <div className="absolute bottom-0 left-0 right-0 h-1 bg-gray-200 z-0"></div>
              </div>
              {/* Linhas de projeto e tarefas */}
              <div className="space-y-6"> {/* Adicionado space-y-6 aqui para espaçamento vertical */}
                {projects.map(project => (
                  <div key={project.id} className="flex items-center"> {/* Removido mb-6 daqui */}
                    <div className="flex-grow relative h-16" style={{ minWidth: `${minWidthTimeline}px` }}>
                      {project.tasks.map(task => {
                        const { left, width, startDate } = taskPositions[task.id] || {};
                        if (!left) return null; 
                        return (
                          <div
                            key={task.id}
                            className={`absolute top-1/2 -translate-y-1/2 ${getTaskColor(task.status)} h-14 rounded-md flex items-center text-sm text-white font-semibold shadow cursor-pointer transition-all duration-300 hover:scale-105`}
                            style={{ left: `${left}px`, width: `${width}px` }}
                            title={`${task.name} (${formatDate(startDate)} a ${formatDate(addBusinessDays(startDate, task.duration))})`}
                          >
                            <span className="pl-2">{task.name}</span>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>
        </div>
      );
    };

    // Componente para o card de análise comparativa
    const AnalysisCard = () => {
      return (
        <div className="bg-white p-6 rounded-2xl shadow-xl w-full sticky top-8 h-fit">
          <h2 className="text-2xl font-bold text-gray-800 mb-4">Análise Comparativa</h2>
          <p className="text-gray-600 mb-4">
            Insira aqui sua análise comparativa entre o cronograma atual e o ideal.
          </p>
          <div className="bg-gray-100 p-4 rounded-md h-96 overflow-y-auto">
            <p className="text-gray-500 italic">
              Este é o espaço para sua análise. Você pode adicionar pontos, gráficos ou textos para comparar os dois cronogramas.
            </p>
          </div>
        </div>
      );
    };

    // Helper function to calculate task positions for a given project array
    const calculateTaskPositionsForApp = (projectsToCalculate) => {
      const positions = {};
      const timelineStartDateBotSac = new Date('2025-06-09T00:00:00'); 
      const daysPerPixel = 40;

      const allTasks = projectsToCalculate.flatMap(p => p.tasks.map(t => ({ ...t, projectId: p.id })));

      let tasksToProcess = [...allTasks];
      let processedCount = 0;
      const maxIterations = allTasks.length * allTasks.length; 

      for (let i = 0; i < maxIterations && processedCount < allTasks.length; i++) {
        const initialTasksToProcessCount = tasksToProcess.length;
        tasksToProcess = tasksToProcess.filter(task => {
          let startDate;
          let canProcess = true;

          if (task.startDate) {
              startDate = task.startDate;
          } else if (task.predecessors && task.predecessors.length > 0) {
            const predecessorEndDates = task.predecessors.map(predId => {
              const predIdParts = predId.split(':');
              const predecessorProjectId = predIdParts.length > 1 ? predIdParts[0] : task.projectId;
              const predecessorTaskId = predIdParts.length > 1 ? predIdParts[1] : predIdParts[0];
              const predPos = positions[predecessorTaskId]; 
              
              if (!predPos) {
                  canProcess = false; 
                  return timelineStartDateBotSac; 
              }
              return addBusinessDays(predPos.startDate, predPos.duration - 1);
            });

            if (!canProcess) return true; 

            startDate = addBusinessDays(new Date(Math.max(...predecessorEndDates)), 1);
          } else {
            startDate = timelineStartDateBotSac;
          }
          
          if (canProcess) {
            const businessDaysFromStart = getBusinessDays(timelineStartDateBotSac, startDate);
            const left = (businessDaysFromStart - 1) * daysPerPixel;
            const width = task.duration * daysPerPixel;
            
            positions[task.id] = { startDate, duration: task.duration, left, width };
            processedCount++;
            return false; 
          }
          return true; 
        });

        if (tasksToProcess.length === initialTasksToProcessCount && tasksToProcess.length > 0) {
          console.warn("Não foi possível processar todas as tarefas no cálculo de posição. Possíveis dependências circulares ou predecessores ausentes.");
          break;
        }
      }
      return positions;
    };


    // Componente principal da aplicação
    const App = () => {
      // Dados iniciais para o cronograma atual
      const initialProjects = [
        {
          id: 'bot_sac',
          name: 'BOT SAC (Menu ACOA)',
          tasks: [
            { id: '96', name: 'HLD', duration: 2, status: 'Concluída', predecessors: [] },
            { id: '98', name: 'Escopo', duration: 3, status: 'Concluída', predecessors: ['96'] },
            { id: '99', name: 'UX - SD', duration: 2, status: 'Concluída', predecessors: ['98'] },
            { id: '100', name: 'Movida - Aprovação SD', duration: 28, status: 'Concluída', predecessors: ['99'] },
            { id: '101', name: 'UX - Spec', duration: 9, status: 'Concluída', predecessors: ['98'] },
            { id: '102', name: 'BI - Marcação Documentação', duration: 2, status: 'Concluída', predecessors: ['100'] },
            { id: '103', name: 'QA - Planejamento Modelagem', duration: 3, status: 'Em Andamento', predecessors: ['102'] },
            { id: '104', name: 'DEV - Desenvolvimento de Fluxo', duration: 7, status: 'Concluída', predecessors: ['103'] },
            { id: '105', name: 'QA - Execução de Testes', duration: 3, status: 'Não Iniciado', predecessors: ['104'] },
            { id: '106', name: 'PO - Certificação', duration: 3, status: 'Não Iniciado', predecessors: ['105'] },
            { id: '107', name: 'GMUD', duration: 1, status: 'Não Iniciado', predecessors: ['106'] },
          ],
        },
        {
          id: 'bot_cpa',
          name: 'Bot CPA',
          tasks: [
            { id: 'hld-cpa', name: 'HLD', duration: 2, status: 'Concluída', predecessors: [], startDate: new Date('2025-07-28T00:00:00') },
            { id: 'aprovacao-hld-cpa', name: '[Movida] Aprovação HLD', duration: 4, status: 'Concluída', predecessors: ['hld-cpa'] },
            { id: 'cpa-1', name: 'Escopo', duration: 2, status: 'Não Iniciado', predecessors: ['aprovacao-hld-cpa'] },
            { id: 'cpa-3', name: 'UX - SD', duration: 2, status: 'Não Iniciado', predecessors: ['cpa-1'] },
            { id: 'cpa-4', name: 'Movida - Aprovação SD', duration: 2, status: 'Não Iniciado', predecessors: ['cpa-3'] },
            { id: 'cpa-2', name: 'UX - Spec', duration: 2, status: 'Não Iniciado', predecessors: ['cpa-4'] },
            { id: 'cpa-5', name: 'BI - Marcação Documentação', duration: 2, status: 'Não Iniciado', predecessors: ['cpa-2'] },
            { id: 'cpa-7', name: 'QA - Planejamento Modelagem', duration: 2, status: 'Não Iniciado', predecessors: ['cpa-5'] },
            { id: 'cpa-6', name: 'DEV - Desenvolvimento de Fluxo', duration: 2, status: 'Não Iniciado', predecessors: ['cpa-7'] },
            { id: 'cpa-8', name: 'QA - Execução de Testes', duration: 2, status: 'Não Iniciado', predecessors: ['cpa-6'] },
            { id: 'cpa-9', name: 'PO - Certificação', duration: 1, status: 'Não Iniciado', predecessors: ['cpa-8'] },
            { id: 'cpa-10', name: 'GMUD', duration: 1, status: 'Não Iniciado', predecessors: ['cpa-9'] },
          ],
        },
        {
          id: 'ura_reservas',
          name: 'URA Reservas',
          tasks: [
            { id: 'hld-ura', name: 'HLD', duration: 2, status: 'Não Iniciado', predecessors: ['bot_cpa:cpa-2'] },
            { id: 'aprovacao-hld-ura', name: '[Movida] Aprovação HLD', duration: 4, status: 'Não Iniciado', predecessors: ['hld-ura'] },
            { id: '183', name: 'Escopo', duration: 2, status: 'Não Iniciado', predecessors: ['aprovacao-hld-ura'] },
            { id: '184', name: 'UX - SD', duration: 2, status: 'Não Iniciado', predecessors: ['183'] },
            { id: '185', name: 'Movida - Aprovação SD', duration: 2, status: 'Não Iniciado', predecessors: ['184'] },
            { id: '186', name: 'UX - Spec', duration: 2, status: 'Não Iniciado', predecessors: ['185'] },
            { id: '187', name: 'BI - Marcação Documentação', duration: 2, status: 'Não Iniciado', predecessors: ['186'] },
            { id: '188', name: 'QA - Planejamento Modelagem', duration: 2, status: 'Não Iniciado', predecessors: ['187'] },
            { id: '189', name: 'DEV - Desenvolvimento de Fluxo', duration: 2, status: 'Não Iniciado', predecessors: ['188'] },
            { id: '190', name: 'QA - Execução de Testes', duration: 2, status: 'Não Iniciado', predecessors: ['189'] },
            { id: '191', name: 'PO - Certificação', duration: 1, status: 'Não Iniciado', predecessors: ['190'] },
            { id: '192', name: 'GMUD', duration: 1, status: 'Não Iniciado', predecessors: ['191'] },
          ],
        },
        {
          id: 'ura_nova_reserva',
          name: 'URA Reservas (Automação Nova Reserva)',
          tasks: [
            { id: 'hld-e2', name: 'HLD', duration: 2, status: 'Não Iniciado', predecessors: ['ura_reservas:186'] },
            { id: 'aprovacao-hld-e2', name: '[Movida] Aprovação HLD', duration: 4, status: 'Não Iniciado', predecessors: ['hld-e2'] },
            { id: 'e2-1', name: 'Escopo', duration: 2, status: 'Não Iniciado', predecessors: ['aprovacao-hld-e2'] },
            { id: 'e2-3', name: 'UX - SD', duration: 2, status: 'Não Iniciado', predecessors: ['e2-1'] },
            { id: 'e2-4', name: '[Movida] Aprovação SD', duration: 2, status: 'Não Iniciado', predecessors: ['e2-3'] },
            { id: 'e2-2', name: 'UX - Spec', duration: 2, status: 'Não Iniciado', predecessors: ['e2-4'] },
            { id: 'e2-5', name: 'BI - Marcação Documentação', duration: 2, status: 'Não Iniciado', predecessors: ['e2-2'] },
            { id: 'e2-7', name: '[QA] Planejamento Modelagem', duration: 2, status: 'Não Iniciado', predecessors: ['e2-5'] },
            { id: 'e2-6', name: '[DEV] Desenvolvimento de Fluxo', duration: 2, status: 'Não Iniciado', predecessors: ['e2-7'] },
            { id: 'e2-8', name: '[QA] Execução de Testes', duration: 2, status: 'Não Iniciado', predecessors: ['e2-6'] },
            { id: 'e2-9', name: '[PO] Certificação', duration: 1, status: 'Não Iniciado', predecessors: ['e2-8'] },
            { id: 'e2-10', name: 'GMUD', duration: 1, status: 'Não Iniciado', predecessors: ['e2-9'] },
          ],
        },
        {
          id: 'bot_rac',
          name: 'BOT RAC',
          tasks: [
            { id: 'rac-hld', name: 'HLD', duration: 2, status: 'Não Iniciado', predecessors: ['ura_nova_reserva:e2-2'] },
            { id: 'rac-aprovacao-hld', name: '[Movida] Aprovação HLD', duration: 4, status: 'Não Iniciado', predecessors: ['rac-hld'] },
            { id: 'rac-escopo', name: 'Escopo', duration: 2, status: 'Não Iniciado', predecessors: ['rac-aprovacao-hld'] },
            { id: 'rac-ux-sd', name: '[UX] SD', duration: 2, status: 'Não Iniciado', predecessors: ['rac-escopo'] },
            { id: 'rac-movida-aprovacao-sd', name: '[Movida] Aprovação SD', duration: 2, status: 'Não Iniciado', predecessors: ['rac-ux-sd'] },
            { id: 'rac-ux-spec', name: '[UX] Spec', duration: 2, status: 'Não Iniciado', predecessors: ['rac-movida-aprovacao-sd'] },
            { id: 'rac-bi-doc', name: '[BI] Marcação Documentação', duration: 2, status: 'Não Iniciado', predecessors: ['rac-ux-spec'] },
            { id: 'rac-qa-planejamento', name: '[QA] Planejamento Modelagem', duration: 2, status: 'Não Iniciado', predecessors: ['rac-bi-doc'] },
            { id: 'rac-dev', name: '[DEV] Desenvolvimento de Fluxo', duration: 2, status: 'Não Iniciado', predecessors: ['rac-qa-planejamento'] },
            { id: 'rac-qa-execucao', name: '[QA] Execução de Testes', duration: 2, status: 'Não Iniciado', predecessors: ['rac-dev'] },
            { id: 'rac-po-certificacao', name: '[PO] Certificação', duration: 1, status: 'Não Iniciado', predecessors: ['rac-qa-execucao'] },
            { id: 'rac-gmud', name: 'GMUD', duration: 1, status: 'Não Iniciado', predecessors: ['rac-po-certificacao'] },
          ],
        },
      ];

      // Defina um segundo conjunto de projetos para o cronograma ideal.
      const idealProjects = JSON.parse(JSON.stringify(initialProjects));

      // 1. Ajusta a data inicial da etapa "HLD" do projeto "BOT CPA" no cronograma ideal
      const botCpaIdeal = idealProjects.find(p => p.id === 'bot_cpa');
      if (botCpaIdeal) {
        const hldTask = botCpaIdeal.tasks.find(t => t.id === 'hld-cpa');
        if (hldTask) {
          hldTask.startDate = new Date('2025-07-28T00:00:00');
        }
      }

      // Calcula as posições das tarefas para o idealProjects após a primeira alteração
      let currentIdealTaskPositions = calculateTaskPositionsForApp(idealProjects);

      // 2. Ajusta a data inicial do projeto "URA Reservas"
      const uraReservasIdeal = idealProjects.find(p => p.id === 'ura_reservas');
      if (uraReservasIdeal) {
        const aprovacaoHldCpaEnd = currentIdealTaskPositions['aprovacao-hld-cpa'] ? 
                                    addBusinessDays(currentIdealTaskPositions['aprovacao-hld-cpa'].startDate, currentIdealTaskPositions['aprovacao-hld-cpa'].duration - 1) : null;
        if (aprovacaoHldCpaEnd) {
          const hldUraTask = uraReservasIdeal.tasks.find(t => t.id === 'hld-ura');
          if (hldUraTask) {
            hldUraTask.startDate = addBusinessDays(aprovacaoHldCpaEnd, 1);
          }
        }
      }

      // Recalcula as posições após o ajuste de "URA Reservas"
      currentIdealTaskPositions = calculateTaskPositionsForApp(idealProjects);

      // 3. Ajusta a data inicial do projeto "URA Reservas (Automação Nova Reserva)"
      const uraNovaReservaIdeal = idealProjects.find(p => p.id === 'ura_nova_reserva');
      if (uraNovaReservaIdeal) {
        const aprovacaoHldUraEnd = currentIdealTaskPositions['aprovacao-hld-ura'] ? 
                                   addBusinessDays(currentIdealTaskPositions['aprovacao-hld-ura'].startDate, currentIdealTaskPositions['aprovacao-hld-ura'].duration - 1) : null;
        if (aprovacaoHldUraEnd) {
          const hldE2Task = uraNovaReservaIdeal.tasks.find(t => t.id === 'hld-e2');
          if (hldE2Task) {
            hldE2Task.startDate = addBusinessDays(aprovacaoHldUraEnd, 1);
          }
        }
      }

      // Recalcula as posições após o ajuste de "URA Reservas (Automação Nova Reserva)"
      currentIdealTaskPositions = calculateTaskPositionsForApp(idealProjects);

      // 4. Ajusta a data inicial do projeto "BOT RAC"
      const botRacIdeal = idealProjects.find(p => p.id === 'bot_rac');
      if (botRacIdeal) {
        const aprovacaoHldE2End = currentIdealTaskPositions['aprovacao-hld-e2'] ? 
                                  addBusinessDays(currentIdealTaskPositions['aprovacao-hld-e2'].startDate, currentIdealTaskPositions['aprovacao-hld-e2'].duration - 1) : null;
        if (aprovacaoHldE2End) {
          const racHldTask = botRacIdeal.tasks.find(t => t.id === 'rac-hld');
          if (racHldTask) {
            racHldTask.startDate = addBusinessDays(aprovacaoHldE2End, 1);
          }
        }
      }

      return (
        <div className="bg-gray-50 flex flex-col lg:flex-row p-8 min-h-screen">
          {/* Coluna esquerda para os dois cronogramas */}
          <div className="w-full lg:w-9/12 space-y-8 lg:pr-8">
            <Timeline projects={initialProjects} title="Cronograma - Plano de Retenção - Atual" />
            <Timeline projects={idealProjects} title="Cronograma - Plano de Retenção - Ideal" />
          </div>
          {/* Coluna direita para o card de análise */}
          <div className="w-full lg:w-3/12 mb-8 lg:mb-0">
            <AnalysisCard />
          </div>
        </div>
      );
    };

    // Renderiza o componente principal no elemento 'root' do HTML
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(App));
  </script>
</body>
</html>
